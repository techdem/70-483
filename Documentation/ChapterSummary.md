# Manage program flow

- Multi-threading allows an application to be made up of a number of cooperating processes.
- When you create a multi-threaded application, its behaviours are spread amongst a number of co-operating tasks. The tasks may be performed in parallel if the host computer has multiple central processor units (CPUs). A single CPU will execute each active task in turn on a round-robin basis.
- Creating a multi-threaded application can be as simple as taking an existing set of actions and using the Task.Parallel library or Parallel LINQ to execute the actions as multiple tasks.
- The .NET Task class provides a high-level abstraction of a running task. Tasks can return values and continuation tasks can run automatically when one or more tasks complete. Tasks can also start child tasks, with the *parent* task being held until all the child tasks have completed.
- The .NET Thread class provides a lower level of abstraction of a running task. Threads cannot return results, nor can you create continuation threads. However, threads can run as foreground or background processes. Tasks can only run as background processes. A foreground process will run until complete, whereas a background process will be terminated upon the completion of the foreground process that created it. It is also possible to set the priority of a thread (although this is purely advisory, it doesn't guarantee that a given thread will be allowed a particular level of access to the processor).
- **Async** and **await** make it very easy to create multi-threaded applications. The **await** keyword precedes a call to a method that has been identified as asynchronous by the **async** keyword. An asynchronous method can return a Task (if the asynchronous method returns void) or a Task\<type> (if the method wishes to return a value). The compiler will generate code that allows an asynchronous method to return to the caller when the **await** keyword is reached. The statements following the **await** will be performed concurrently. This way of working is of particular value when building the user interface to a program. As asynchronous action bound to a button press will unblock the user interface at the first **await**, rather than stopping the user interface until the action performed by the button has completed. An application can catch exceptions thrown during asynchronous calls by enclosing the awaited action in an exception handler, but this only works if the awaited actions returns a value. For this reason, void asynchronous calls should be avoided as there is no way of determining whether they succeeded or not.
- The standard .NET collection classes are not *thread safe*. This means that if multiple tasks attempt to share data using a List, the contents of the list will be corrupted. The .NET framework provides a set of concurrent collections that can be shared by multiple active tasks. The **BlockingCollection** class provides a wrapper around **ConcurrentStack**, **ConcurrentQueue** and **ConcurrentBag** concurrent collections. Tasks using a **BlockingCollection** will be blocked (paused) if there is no room for additional items, or if they try to take items from an empty collection. The concurrent collections provide "try" versions of methods to extract items which return whether an action succeeded or not. This is because in the time between determining that there are items available and reading them it is possible that another task could have removed the items. The **ConcurrentDictionary** class provides additional methods for the conditional update of items in the dictionary.
- Multi-threaded applications are vulnerable to *race conditions* where actions by a task on a shared data item are not run to completion before that task is replaced by another.
- Race conditions can be addressed by making actions *atomic*, in that they will always complete before another task is allowed to perform the action. This is achieved by the use of lock objects. A task claims the lock and while it has the lock, other tasks trying to claim that lock and enter the atomic code will be blocked. This may results in a queue of blocked tasks waiting for a particular lock to be released.
- Two tasks waiting for locks from each other are said to be *deadlocked* or in a *deadly embrace*. Deadlocks can arise as a result of code which waits for access to a lock object while inside an atomic action. This should be addressed by good design.
- The Monitor mechanism for locking can be used in preference to the lock keyword if an application would benefit from tasks being able to determine whether or not hey can have access to an atomic action, rather than being blocked as soon as they try to aquire the lock.
- Simple actions, such as updating a particular variable, can be achieved by using the interlocked operations, rather than creating atomic blocks of code.
- Variables that may be used by multiple processes can be marked as "volatile". This tells the compiler not to perform optimisation such as caching the value of the variable in a processor register, or changing the order of the instructions.
- Tasks can be cancelled by the use of cancellation tokens. As a task runs it must check state of the token to determine if a cancellation has been requested. This is an important difference between a Task and a Thread. Threads can be aborted by another process at any time. One task can request that another task be cancelled, but this will only actually result in that thread ending if the code in the task is checking the cancellation token. Note that this does not mean that an active task can never be removed from memory however, because tasks run in the background they are automatically terminated upon completion of the foreground process that created them.
- Methods in an object my be made *thread safe* if they are to be used in applications that contain multiple tasks. Access to data members of the class containing the thread safe method must be managed in an atomic manner. Parameters passed into the method by reference are vulnerable to changes to elements in the parameter that may occur while the method is running.
- A **while** construction is useful in situations where you want to repeat something as long as condition is true. A do-while construction is useful in situations where you want to do something and then repeat if the action failed.
- A **for** construction is an easy way to perform initialisation, test and update actions on a **loop**. A for construction frequently involves the management of a counter value, but this is not the only way in which this construction can be used.
- A **foreach** construction can be used to enumerate the items in a collection. The collection provides a method that will provide an enumerator which is then iterated by the **foreach** construction. The items in the collection are provided as read-only.
- The **break** statement allows a program to exit a loop immediately. A large number of breaks in a loop can make it hard to discern the circumstances in which the loop exited. A loop can also be exited upon return from the method in which the loop is running and when code in the loop throws an exception that is not caught in the loop.
- The **continue** statement allows a program to return to the "top" of a loop and repeat the loop without going any further through the loop code. Note that any update and test behaviours will be performed when a continue statement runs.
- An **if** construction allows the conditional execution of a statement or block of statements. If constructions are controlled by a logical expression and can be followed by an **else** clause that identifies the statement to be performed if the condition is false. If conditions can be nested, an **else** portion of an **if** construction always binds to the "closest" if.
- Logical expressions evaluate to true or false. Variables can be compared using relational and equality operators. Logical values can be combined using **and**, **or** and **exclusive or** operators. The **and** operator and the **or** operator have "short circuit" versions that are only evaluated to the point where the value of the expression result can be determined.
- The **switch** construction allows the selective of a given behaviour from the value of a control value which can be an integer, string or character. A default behaviour can be specified if the control value does not match any of the selections.
- An expression contains operands and operators. The operands are literal values or variables. Operators have priority and associability that determine the point that the operator is applied during the evaluation of the expression.
- C# programs can use delegates to create variables that can serve as references to methods in objects. An object wishing to receive notifications from a publisher can use a delegate to specify a method to be called by the event publisher. A single publisher delegate makes calls to its subscribers, each of which has provided a delegate.
- The **event** keyword allows a delegate to be used in a secure way and the **EventArgs** classes describe a pattern that is used throughout .NET to allow events to deliver data into a subscriber.
- Delegates can also be used as references to individual methods. A delegate referring to a method can be regarded as a piece of data which describes an action.
- A lambda expression allows an action to be expressed directly and provides a convenient shorthand when writing code. The type of parameters and value returned by a lambda expression are inferred from the context of the call.
- An exception is thrown by a program to indicate a situation in which the program cannot continue normal operation. Execution is transferred from the statements being executed in a **try** block of code to an exception handler in a **catch** block, which was written to deal with the exception. An exception that is thrown in code that is not within a try construction will cause the executing thread to terminate.
- A **finally** element can be used in a try construction to specify code that will always be executed.
- A program throws an exception by creating a new exception instance and then using the **throw** keyword to throw it. All exception objects are derived from the Exception class. There are a large number of exception types that are used in the .NET libraries to describe error conditions; a programmer can also create their own exceptions types that contain their own error-specific information.
- An exception object contains information that describes the error, including a "stack trace" that indicates the point in the program source where the exception is thrown. An exception can also contain an inner exception reference so that a new exception can be wrapped around one that has been caught, before passing the exception to another layer of exception management.

# Create and use types

- Objects in a solution can be managed by value or by reference. A struct is a value type, which means that during assignment the contents of the struct (the value) is copied from one variable to another. A class is a reference type, which means that during assingment the destination of the assingment is made to refer to the same object as the source of the assingment.
- An immutable object is one that cannot be changed. Immutable objects, for example DateTime, provide methods that can be used to provide new, mutated copies of the original. For example, the DateTime structure provides a method that can be used to return a new DateTime structure that represents a given number of days into the future.
- A generic type can be used as a "placeholder" in a type design, so that the type of object that a type works on can be established dynamically. A good example of a situation where generic types are used is in the creation of lists and dictionaries.
- Types can be given a constructor method that is called when a new instance of the type is created. A constructor can be given parameters that can be used to initialise the object. If the constructor detects that the initialisation data is invalid it must interrupt the construction process by throwing an exception, as the object will be created when the constructor completes. Constructors can be overloaded to provide different ways in which a given type can be instantiated. By use of the "this" syntax one constructor in type can call another constructor, to allow the creation of a master constructor and avoid code duplication in objects. Classes can contain a static constructor, which is called once when the first instance of the class is created.
- Types can contain methods that allow an object to perform behaviours. A method accepts a number of parameters and has a particular type. A method of type void does not return a value, whereas a method with any other type must return a result of that type.
- An extension method can be added to a class to add to the functionality of the class. The extension method does not have access to any of the private data members of the class it is added to.
- Parameters to a method can be identified by their names when called. This improves the readability of programs and also reduces the likelihood of errors which may be caused by parameters being entered in the wrong sequence.
- Parameters to a method can be made optional by providing a default value for the parameter. If the parameter is left out of the method call the default value is used instead.
- Objects can provide indexed properties which can be used to provide an index value (usually an integer) to identify the item to be returned.
- Methods in a single type can be overloaded. This means that the type will contain multiple versions of the same method, each of which has a different signature. Method overloading is used in situations where there are multiple ways of performing a given task from different data inputs.
- Methods in a class hierarchy can be overridden. To be overridden a method must be marked as virtual. When a virtual method is called on an instance of a class in the hierarchy the system will search up the class hierarchy for an implementation of the method, starting at the class of the object. The first implementation that is found is called. Method overriding is used in situations where objects in a class hierarchy need to be able to perform a given action in their own particular way. The **base** keyword allows a method to call the method it has overridden.
- Every item in an application is of a particular type. The C# type system will automatically convert between reference and value types and automatically convert (widen) values when it is sensible to do so and no data will be lost.
- If a type conversion will result in data loss (narrowing) the programmer must use casting to explicitly request the conversion of the values.
- Dynamic types are provided so that a C# application can interact with languages and services which are not statically typed. They allow the compiler to be told to ignore the type of an object and build the program even if the typing information indicates errors.
- When a dynamic type is used the type of the variable that is created is inferred from the context of the use. This means that mistakes that would have been detected as compilation errors are now changed into run-time errors.
- Dynamic types are especially useful when interacting with Component Object Model (COM) based services as they can be automatically mapped onto the correct types from the context of their use.
- The C# access modifiers allow members of a class to be hidden from code outside the class. Unless you specify otherwise, class members are private to a class and not visible outside it. Making a data member public will allow uncontrolled access to that data member in the class, which may not be a good idea.
- C# properties allow get and set behaviours to get control when an external code wishes to interact with a member of a class. The property can control access to private member of the class that holds a *backing value* for the data that is being managed by the class. Properties can provide only get behaviours can have different access modifiers so that the get behaviour for a property can be made public and the set behaviour private.
- Generally speaking, methods that a class exposes for other classes to use should be made public, and data contained within the class should be made private.
- The **protected** access modifier allows a class member to be made visible within classes in a class hierarchy and the **internal** access modifier allows a class member to me made visible to code in the same assembly as the class member.
- Methods in a class that implement the behaviours of an interface can be identified as explicitly implementing this interface. This improves encapsulation as it means that the only context in which those methods can be used is via a reference to the interface, not a reference to the object. Explicit implementation of behaviours also removes the potential for confusion if a class implements multiple interfaces and the same method appears in some of the interfaces.
- A C# class can implement an interface that contains a set of method signatures. Implementing an interface involves providing a method that matches each of the methods described in the interface. A class that implements an interface can be referred to by references of the interface type.
- A C# class can serve as the base class for a child class that extends it. A child class inherits all of the members of the base class and can use the override mechanism to provide overridden version of methods in the base class which have a behaviour more specific to the child class. For a method in a base class to be overridden it must be declared as virtual. An overriding method can use the **base** keyword to call overridden methods in the base class.
- A programmer can create replacement methods for those in a base class. This is not to be encouraged.
- A class can be declared as sealed to prevent it from being used as the basis of child classes. Methods in a class that extend those in a base class can also be declared as sealed, preventing them from being overridden.
- To construct a child class a program needs to create an instance of the base class. If a base class has a constructor the child class must call this and supply any required parameters. The **base** keyword is used in the constructor for this purpose.
- A class can be declared as abstract, in which case it will contain signatures of methods which are to be implemented in child classes. Abstract classes can serve as templates for classes.
- A reference to a base class can refer to any objects that are created from classes that extend the base class. However, the reverse is not true. A reference to a child class is not able to be made to refer to an instance of the parent.
- A class can implement the **IComparable** interface. This means that it contains a method called **CompareTo** which can be used to determine the ordering of objects of that type. The **IComparable** behaviour can be used by methods such as the **Sort** method provided by the **List** type, which can place objects in order.
- A class can implement the **IEnumerable** interface, which means that it provides a method **GetEnumerator** which will supply an enumerator which can be used by a consumer of the enumeration (for example a **foreach** construction) to work through the class.
- The C# **yield** keyword provides an easy way for a programmer to create enumerators. It retains the state of the enumerator method until the next item is requested from the enumeration by the consumer of the enumeration.
- A class can implement the **IDisposable** interface. The class will contain a **Dispose** method that can be called to instruct an instance of the class to release critical resources that it is using. The **Dispose** method is not called automatically by the garbage collection process, but it can be called automatically if the instance of the object is created and used within a C# program using construction.
- The **IUnknown** interface can be used when creating .NET code that must interact directly with Component Object Model (COM) objects.
- Metadata is data about data. In the context of a C# program, the metadata for the code would be expressed in the form of one or more attribute instances that are attached to code elements. This metadata is stored in the assembly file that is created when the program is built and loaded into attribute class instances when the assembly is loaded.
- Attribute classes extend the Attribute class and have names that end with the text "Attribute". An attribute class can be empty, in which case it just indicates that a particular attribute is applied to an item, or an attribute can contain data elements which can be accessed programmatically. Attributes can be applied to many different elements in a program; an **AttributeUseage** attribute can be added to an attribute declaration to specify objects and classes that can have an attribute applied.
- Reflection allows a program to investigate the contents of a type and programmatically interact with it.
- Reflection can be used on an assembly to allow a program to determine the characteristics of types in the assembly. This can be used to allow a component-based system to automatically select and load the components that it needs.
- Program's code can be created programmatically by using the CodeDOM document model which allows namespaces, classes, properties and class members to be specified. A CodeDOM object can be output as a binary assembly file or as a source file in C# or Visual Basic.
- Another way to programmatically create code behaviours is to create lambda expression trees which contain lambda expressions that give the actions to be performed, along with a range of expression node types that specify other program actions. Expression trees are used to express programmatic behaviour for such things as LINQ queries and the implementation of dynamic languages.
- Garbage collection of objects makes program creation much easier. The garbage collection system in C# runs automatically and will delete unused objects (those that are not referred to by any reference).
- Application threads are paused while the garbage collection process runs.
- The garbage collector recognises persistent objects (those which are present after a garbage collection) and omits those from the garbage collection process.
- The garbage collection process can be initiated manually, although this is not recommended.
- Unused objects that contain references to resources that need to be released when the object is deleted can contain a finaliser method that is executed during the garbage collection process. The finaliser method can release resources allocated to the object.
- In preference to a finaliser method, an object can implement the **IDisposable** interface and contain a **Dispose** method that can be used by the application to instruct the object to release any resources. The using statement can be used to ensure that the **Dispose** method is called on an object which is used in only one part of a program.
- By using the dispose pattern, an object can combine the use of finaliser and **Dispose** to ensure that resources held by the object are released correctly.
- A string is a collection of characters of arbitrary length.
- String variables are immutable (they cannot be changed) but they are managed by reference. This combination means that they can be treated as value types.
- During compilation multiple copies of string literals for a particular string are mapped onto a single string instance in memory. In other words, if a program assigns the string literal "cheese" to several different string variables this would result in a single string value containing the text "cheese" being created to which all the variables would be made to refer.
- Building up a large string by adding many strings together will result in the creation of a large number of substrings. The **StringBuilder** type provides a string implementation which is mutable. A program can modify the contents in a **StringBuilder** instance. **StringBuilders** provide a more efficient means of assembling large strings.
- The **StringReader** and **StringWriter** classes allow strings to be used by programs that work with **TextReader** and **TextWriter** streams.
- The string type provides a range of methods for working with strings. It is possible to establish the location of substrings within the string, extract them and match the start and the end of a string.
- The contents of a string cannot be changed (strings are immutable) but the **Replace** string method can be used to create a new string instance with updated contents.
- String matching can be performed using the character codes or according to particular cultures where multiple spellings of the same word may be matched.
- Strings can be enumerated, for example by using **foreach** construction.
- Strings can implement the **IFormattable** interface, which means that they will contain an additional **ToString** method that accepts formatting and culture information.
- String interpolation allows a program to use string literals (preceded by a $ character) that combine formatting information and the names of variables to be formatted and incorporated into the string. Interpolated strings are processed at compile time to produce composite format strings.

# Debug applications and implement security

- Data validation is a crucial component of a secure application. It must be designed into an application at the start.
- JavaScript Object Notation (JSON) provides a way of converting a C# class structure into a document string that contains a series of name values pairs that match the elements in the class. Private elements in a type are not automatically stored, but can be.
- The Newtonsoft JSON library can be used to convert classes to and from JSON strings. It will throw exceptions if given an invalid JSON string to decode. The exceptions contain information that describe the position in the source text of the error.
- XML (eXtensible Markup Language) is another means by which classes can be converted into text documents. XML documents can be validated by XML schemas that describe a particular document structure.
- A program should use typed collection classes so that errors with the use of types will be detected at compile time, rather than causing exceptions when the program runs.
- If there is any prospect of an application making use of multiple threads it should use the concurrent collection classes.
- Selecting the correct form of collection (queue, stack, indexed storage, linked list or dictionary) will improve performance and ease of coding.
- An ASP&#46;NET (Active Server Pages) application can be built on an Entitity Framework data store that provides the Model element of a Model View Controller (MVC) pattern. In this mapping the Views of the data are provided by HTML web pages and the Controllers (which respond to inputs from the views and update the data model) are created as C# classes.
- When deciding how much effort ot put into retaining object integrity, it is important to consider the risk of an integrity failure and the impact that such a failure will have. The allocation of effort to mitigate risk should be made at the start of a project once the risks have been identified and their impact assessed.
- Actions that are performed on data should be "atomic", in that they should not be made up of a number of smaller actions that are performed independently. A non-atomic (or made up of a number of other parts) action may fail part way through, leading to an object being left in an invalid state.
- Regular expressions can be used to edit data and also to match against a given data element to validate its structure and contents.
- C# provides built-in **Parse** and **TryParse** behaviours that can be used to convert data from string values into a destination type. The **Parse** method will throw an exception if the conversion fails. The **TryParse** method will return **True** or **False**, which is easier to manage than creating exception handlers to deal with what should be regarded as a fairly common issue.
- C# provides a **Convert** class that contains a number of methods that will perform data conversion.
- The data classes in an Entity Framework application can be given extra attributes to indicate validation actions.
- Cryptography is sending messages that cannot be read by eavesdroppers. Cryptoanalysis is reading messages that you're not supposed to be able to read. Encryption is the process of converting plain text (the mssage) into encrypted data that has to be decrypted so that it can be read. Decryption is the reverse of encryption.
- A key is an item that is used in the encryption and decryption process. Encryption that does not involve the use of a key is vulnerable to statistical techniques that can reveal the encryption through patterns in the language and conventions of the conversing parties.
- Symmetric encryption uses the same key at each end of an encrypted conversation. This can provide high levels of security and is easy for computers to perform; but requires that both sides of a conversation have copies of the key.
- There are .NET libraries that will perform symmetric encryption. The encryption algorithms are exposed in the form of child classes of the **SymmetricAlgorithm** abstract class, making it easy to change encryption algorithms. The encryption process itself is provided as a stream, making it easy to integrate encryption into data transfer. The preferred encryption mechanism is AES (Advanced Encryption Standard).
- Assymetric encryption uses different keys for sender and receiver. Data encrypted by one key can be read by the other key. The mathematical techniques used to generate the keys make it very computationally difficult to deduce one key given the other, or to determine either key from encrypted data.
- Assymetric encryption requires more computer processing power to perform and is only suitable for comparatively small packets of data. It is used for transferring symmetric key values and for signing digital documents to validate them and prove their origin.
- In a public/private encryption a party (perhaps called Alice) will make ony assymetric key public and keep the other private. Other parties can use this public key to encrypt messages that can only be read by Alice. This is how you can send Alice a symmetric key that you can then use to have an encrypted conversation with her.
- The **RSACryptoServiceProvider** class provides RSA encryption for blocks of bytes. It does not encrypt streams. It is possible to generate XML that describes key values, public or private. It is also possible to store key values in a key store on a computer, either on a user or a machine basis.
- The public/private key mechanism is a convenient way to establish secure communications, but it does not provide any form of identity validation. Anyone could make a public key and claim to be Alice. Certification Authorities are trusted parties who can validate the identity of a given party. The party, (perhaps called Bob) can send Alice a public key that has been signed by a certificate that is hosted by a Certification Authority.
- The **makecert** program can be used to generate test certificates to be used during development. These can be stored in files, or in the certificate store of a given machine.
- Signing a document allows the receiver to determine who sent the document, and that the contents have not been altered. To achieve this, a program must calculate a "hash" of the document. A hash function is applied to a block of data to generate a much smaller value (tens of bytes) that are unique to that block. This is called the "block manifest".
- Hash functions can be vulnerable to attack, in that it may be possible to change the contents of a document without the hash function changing, raising the possibility of undetectable tampering. The longer the block manigest, the better. The SHA1 (Secure Hash Algorithm 1) has been compromised and is not recommended for use. SHA2 is better, but SHA3 will become the standard in the future. SHA3 is not presently supported by a .NET library although implementations are available via GitHub.
- An assembly is the basic building block of .NET applications. It can have an entry point and serve as the starting point of an application, in which case it will have the language extension .EXE or an assembly can contain a library of classes, which will be dynamically loaded as required, in which case the assembly file will have the extension .DLL.
- The assembly file contains a manifest that describes the contents of the assembly and identifies any other assemblies that are used by code in that assembly.
- The program code in an assembly is written in Microsoft Intermediate Language (MSIL), which is produced by compiling the original program source code that can be written in any .NET compatible language.
- An assembly contains version information. Assemblies with strong-names are signed using a private key that allows each assembly to be uniquely identified via its corresponding public key. This also protects against changes to the content of the assembly file.
- The code in a strong-named assembly is not protected in any way by the strong-name, and code signing does not prove the authenticity of the originator of the assembly. Services such as Authenticode, which are used by the Windows Store, can provide digital certificates that can be used to sign strong-named assemblies and identify the author.
- Assemblies can be stored in the Global Assembly Cache (GAC). This allows the assembly to be shared among applications on a machine. Multiple versions of the same assembly can be stored "side-by-side" in the GAC and each will be used appropriately by different applications on the machine.
- A faulty assembly in the GAC can be replaced by a fixed one and assembly binding redirection can be used to cause applications to target the new version. Redirection can be specified at application, publisher, and machine level by the use of policy files.
- WinRT is a runtime system that is based on compiled C++ code. It uses the same metadata fundamentals of .NET assemblies to express the behaviour of an object. The behaviours are expressed in a file of type WinMD (Windows MetaData). This can be a wrapper around existing C++ (in the case of the Windows API) or the WinMD file can contain code. It is possible to create Windows Runtime Components (elements that express their behaviour in WinMD files) from C# classes, although there are some restrictions on the behaviours of the C# objects than can be used in WinRT.
- The C# compiler understands processor directives. A directive is a command preceded by a # character. The #if directive can be used to control which code elements of a program are actually compiled into code. It tests to see if a given symbol has been defined using the #define directive. The #if directive can be used to switch on and off diagnostic elements of a program and to create custom versions of programs. However, it should not be overused beucase it can lead to confusing code.
- The **DEBUG** symbol is defined if the program is compiled with the debug option. It can be used to activate code that will run when the program is being debugged.
- The **Conditional** attribute can be used to control the execution of a method based on a particular symbol. If the symbol is not defined the statements that would call the method are omitted from a program when it is built.
- The #warning directive produces a warning message when a program is built.
- The #error directive produces a compilation error with the specified message when the program is built. It can be used to prevent a program from being compiled if it contains an incompatible selection of conditional options.
- The #pragma directive allows a programmer to identify blocks of source code were some, or specified, compiler warnings will be ignored.
- The #line directive lets the developer set the line numbers reported by Visual Studio during compiling and tracing through the source file. It is useful if a source code file has automatically generated code inserted during the build process. A #line directive can also be used to hide source code lines from the debugging process. A #line directive can also be used to hide source code lines from the debugging process. A #line directive can also be used to set the name for the source file that will be displayed by diagnostic messages.
- A Visual Studio project can have a number of build configurations that specify debug options and target platforms. A newly created project will have debug and release build configurations. We can use the Configuration Manager in Visual Studio to configure build configurations and create new ones.
- The assemblies produced by a debug build will contain code that implements unused variables and methods that are not called. A release build will discard unused elements and will also perform optimizations that may change the order in which statements are performed when the program runs. For this reason, debug breakpoints cannot be set in release builds.
- When a program is built Visual Studio creates a Program Debug Database file, which contains the names of the symbols used in the program and the locations where their values are stored. The file also contains mappings of source code statements to the MSIL that implements them. A given database file is mapped to a particular source code file using a GUID that is stored in both files. A program will run if the program database file is missing, but it cannot be debugged without one.
- Program database information can be shared from a symbol server. The Microsoft symbol server provides symbols that allow developers to step through Microsoft libraries. Development teams can create their own symbol servers to share symbol information within a project.
- A program database file can contain public and private elements. Public elements are those that are visible in the assemblies themselves, for example public methods. Private elements include things like local variables. Access to a database containing private elements could give insights into how the code works, which might be a potential security issue. The **pdbcopy** program, part of the Debugging Tools for Windows, can be used to copy a database file and remove public elements.
- The **Debug** and **Trace** classes in **System.Diagnostics** can be used to generate messages as a program runs. They can also be used to test assertions.
- When a program is built using the Debug option, the Debug code will be executed when it runs. Trace code is executed if the program is built using the **Debug** or **Release** options.
- The Trace object provides information, warning and error levels of output.
- Listeners can be bound to the Debug and Trace classes. There are different forms of listener that can be used to display output, log output as comma separated lists, and as XML formatted data.
- The **TraceSource** class manages the production of tracing events. There are several types of events, from informational events that are produced during normal operation, through to warning, error, and critical events. One or more **TraceListener** instances can be bound to a **TraceSource** instance to receive notification of events.
- The **TraceSwitch** class can be used to determine the level of tracing to be performed by a program. The program code can test the value of a **TraceSwitch** instance to determine what level of tracing output to produce.
- The **SourceSwitch** class is used to control the tracing messages produced by a **traceSource** instance. An instance of the **SourceSwitch** class can be associated with a **traceSource** to determine the tracing events to be produced.
- The level of tracing output can also be defined by the creation of the **SoruceSwitch** values in the config file of an application. This allows the tracing behaviour of a program to be changed without changing the actual program code of the application.
- Profiling of an application is used to determine the elements that are using up the most processor time when the program runs. These elements can then be specifically optimised to improve performance, if required. The simplest form of profiling is to use the **Stopwatch** class to measure elapsed time as the program runs.
- Visual Studio provides a range of Profiling tools. The default profiler allows a number of profiling options. The simplest, CPU sampling, is usually sufficient to determine where a program is spending most of its time. This option profiles the loading on the computer and shows the "Hot Path", which identifies the methods consuming most of the processor time.
- Performance counters are maintained by the operating system and can be used to view many different items of information about the host computer, including memory and processor use.
- An application can create and update its own performance counters. Their values will be held by the operating system. There are a range of different counter types including ones that just count values, and ones that will evaluate the number of events per second. Programs need Administrator permissions to be able to create their own performance counter.
- The values of performance counters can be viewed using the Performance monitor (perfmon) program. Programs can also read performance counters to create their own dashboard displays.
- The operating system also manages an Event log. Programs can create their own event category and event types and add events to the log. It is also possible for a program to read events and also bind a listener method to a particular event to receive notifications when that event is logged.

# Implement data access

- A stream is an object that represents a connection to a data source. A stream allows a program to read and write sequences of bytes and set the position of the next stream operation.
-  The **Stream** class is the abstract parent class that defines fundamental stream behaviours. A range of different child classes extend this base class to provide stream interaction with different data sources.
-  The **FileStream** class provides a stream interface to file storage.
-  A file contains a sequence of 8-bit values (bytes) that can be encoded into text using a particular character mapping. The **Encoding** class provides methods for different character mapping.
-  The **TextWriter** and **TextReader** class are abstract classes that define operations that can be performed with text in files. The **StreamWriter** and **StreamReader** class are implementations of this class that can be used to work with text files in C#.
-  Stream classes have constructors that can accept other streams, allowing a program to create a "pipeline" of data processing behaviours that are ultimately connected to a storage device.
-  The **File** class is a "helper" class that contains static methods that can be used to write, read, append, open, copy, rename, and delete files.
-  It is important that a program using files deals with any exceptions that are thrown when the files are used. File operations are prone to throwing exceptions.
-  The actual file storage on a computer is managed by a file system that interacts with a partition on a disk drive. The file system maintains information on files and directories which can be manipulated by C# programs.
-  The **FileInfo** class holds information about a particular file in a filesystem. It duplicates some functions provided by the **File** class but is useful if you are working through a large number of files. The **File** class is to be preferred when working with individual files.
-  The **DirectoryInfo** class holds information about a particular directory in a filesystem. This includes a list of **FileInfo** items describing the files held in that directory.
-  A path describes a file on a filesystem. Paths can be absolute, thus starting at the drive letter, or relative. The **Path** class provides a set of methods that can be used to work with path strings, including extracting elements of the path and concatenating path strings.
-  A C# program can use the **HttpWebRequest**, **WebClient**, and **HttpClient** classes to communicate with an HTTP server via the internet. **HttpWebRequest** provides the most flexibility when assembling HTTP messages. **WebClient** is simpler to use and can be used with await and async to perform asynchronously. **HttpClient** only supports asynchronous use and must be used when writing Universal Windows Applications.
-  Programs can (and should) perform file operations asynchronously. The **FileStream** class provides asynchronous methods. When catching exceptions thrown by file operations, ensure that the methods being awaited do not have a void return type.
-  A database provides data storage for applications in the form of tables. A row in a table equates to a class instance. Each row can have a unique ID (called a *primary key*) which allows other objects to refer to that row.
-  Programs interact with a database server by creating an instance of a connection object. The connection string is used to configure this connection, to identify the location of the server and to provide authentication details. ASP&#46;NET applications can be configured with different environments for development and production, including the contents of the connection string.
-  A database responds to commands expressed in Structured Query Language (SQL). SQL is plain text that contains commands and data elements. Care must be taken when incorporating user entered data elements in SQL queries because a malicious user can inject additional SQL commands into the data.
-  When creating ASP&#46;NET applications, the SQL commands to update the database are performed by methods that act on objects in the application.
-  A program can download data from a web server in the form of a JSON or XML document that describes the elements in an object.
-  A program can download data from a web server in the form of an XML document. XML documents can be parsed element by element or used to create a Document Object Model (DOM) instance, which provides programmatic access to the elements in the data.
-  A web service takes the form of a server and a client. The server exposes a description of the service in the form of method calls that are implemented by a proxy object created by the client. The method calls in the client proxy object are translated into requests sent to the server. The server performs the requested action and then sends the response back to the client, which receives the response in the form of the result from the method call.
-  LINQ allows programmers to express SQL-like queries using "query comprehension syntax".
-  LINQ queries can be performed against C# collections, database connections, and XML documents.
-  A LINQ query generates an iteration. The execution of the query is deferred until the iteration is enumerated, although it is possible to force the execution of a query by requesting the query to generate a List, array, or dictionary as a result.
-  LINQ queries are compiled into C# method calls. A programmer can express a query as methods if required.
-  A LINQ query generates an iteration as a result. This may be an iteration of data objects or an iteration of anonymous types, which are created dynamically when the query runs.
-  A program can work with anonymous types by using the **var** type, which requests that the compiler infer the type of the data from the context in which it is used. Using **var** types does not result in any relaxation of type safety because the compiler will ensure that the inferred type is not used incorrectly.
-  The output from one query can be joined with a next, to allow data in different sources (C# collections or database tables) to be combined.
-  The output from a query can be grouped on a particular property of the incoming data, allowing a query to create a summary information that can be evaluated by the aggregate commands, which are sum, average, min, max, and count.
-  LINQ to XML can be used to perform LINQ queries against XML documents held in the **XDocument** and **XElement** objects. These objects also provide behaviours that make it easy to create new XML documents and edit existing ones.
-  Serialisation involves sending (serialising) the contents of an object into a stream. The stream can be deserialised to create a copy of the object with all the data intact. The code content (the methods) in an object are not transferred by serialisation.
-  Classes that are to be serialised by the binary serialiser must be marked using the **[Serializable]** attribute, which will request that all the data items in the class be serialised. It is possible to mark data items in a class with the **[NotSerialized]** attribute if it is not meaningful for them to be serialised.
-  Binary serialisation encodes the data into a binary file. Binary serialisation serializes public and private data elements and preserves references. Sensitive data should not be serialised without paying attention to the security issues, because a binary serialised file containing private data can be compromised.
-  A programmer can write their own serialisation behaviours in a class, which save and restore the data items using the serialisation stream. Note that customised serialisation behaviours may be used to illicitly obtain the contents of private data in a class, and so must be managed in a secure way.
-  A programmer can add methods that can modify the contents of a class during the serialisation and deserialisation process. This allows you to create classes that can create default values for missing attributes when old versions of serialised data are deserialised.
-  The XML serialiser serialises public elements of a class into XML text. The value of each element is stored in the file. References in objects that are serialised are converted into copies of the value at the end of the reference. There is no need for the **[Serializable]** atribute to be added to classes to be serialised using XML.
-  The JSON serialiser uses the JavaScript Object Notation to serialise data into a stream.
-  The **DataContract** serialiser can serialise public and private data elements into XML files. Classes to be serialised must be given the **[DataContract]** attribute and data elements to be serialised must be given the **[DataMember]** attribute.
-  The C# language allows a program to create arrays. An array can contain values or reference types. The size of the array (the number of elements in it) is fixed when the array is created and cannot be changed. Array elements are accessed by the use of a subscript/index value which is 0 for the element at the start of the array. Arrays can have multiple dimensions.
-  The **ArrayList** is a collection class that provides dynamic storage of elements. A program can add and remove elements. Elements in an **ArrayList** are managed in terms of references to the object type, which is the base type of all types in C#. This means that a program can store any type in an **ArrayList**.
-  The **List** type uses generics to allow developers to create lists of a particular type. The list stores elements of the given type. It is used in exactly the same way as an **ArrayList**, with the difference that there is no requirement to cast elements removed from the **List** to their proper type.
-  Dictionaries provide storage organised on a key value of a particular type. The key value must be unique for each item in the dictionary.
-  Sets store a collection of unique values. They are useful because of the set functions that they provide. Sets are useful for storing tag values and other kinds of unstructured properties of an item.
-  A **Queue** is a First-In-First-Out (FIFO) storage device that provides methods that can be used to **Enqueue** and **Dequeue** items.
-  A program can customise a collection by extending the base collection type and adding additional behaviours.
-  Programmers can create their own collection types by creating types that implement the **ICollection** interface.
-  A **Stack** is a Last-In-First-Out (LIFO) storage device that provides methods that can be used to **Push** items on the stack and to **Pop** them off.

#### Author: Rob Miles