# Manage program flow

- Multi-threading allows an application to be made up of a number of cooperating processes.
- When you create a multi-threaded application, its behaviours are spread amongst a number of co-operating tasks. The tasks may be performed in parallel if the host computer has multiple central processor units (CPUs). A single CPU will execute each active task in turn on a round-robin basis.
- Creating a multi-threaded application can be as simple as taking an existing set of actions and using the Task.Parallel library or PArallel LINQ to execute the actions as multiple tasks.
- The .NET Task class provides a high-level abstraction of a running task. Tasks can return values and continuation tasks can run automatically when one or more tasks complete. Tasks can also start child tasks, with the *parent* task being held until all the child tasks have completed.
- The .NET Thread class provides a lower level of abstraction of a running task. Threads cannot return results, nor can you create continuation threads. However, threads can run as foreground or background processes. Tasks can only run as background processes. A foreground process will run until complete, whereas a background process will be terminated upon the completion of the foreground process that created it. It is also possible to set the priority of a thread (although this is purely advisory, it doesn't guarantee that a given thread will be allowed a particular level of access to the processor).
- **Async** and **await** make it very easy to create multi-threaded applications. The **await** keyword precedes a call to a method that has been identified as asynchronous by the **async** keyword. An asynchronous method can return a Task (if the asynchronous method returns void) or a Task\<type> (if the method wishes to return a value). The compiler will generate code that allows an asynchronous method to return to the caller when the **await** keyword is reached. The statements following the **await** will be performed concurrently. This way of working is of particular value when building the user interface to a program. As asynchronous action bound to a button press will unblock the user interface at the first **await**, rather than stopping the user interface until the action performed by the button has completed. An application can catch exceptions thrown during asynchronous calls by enclosing the awaited action in an exception handler, but this only works if the awaited actions returns a value. For this reason, void asynchronous calls should be avoided as there is no way of determining whether they succeeded or not.
- The standard .NET collection classes are not *thread safe*. This means that if multiple tasks attempt to share data using a List, the contents of the list will be corrupted. The .NET framework provides a set of concurrent collections that can be shared by multiple active tasks. The **BlockingCollection** class provides a wrapper around **ConcurrentStack**, **ConcurrentQueue** and **ConcurrentBag** concurrent collections. Tasks using a **BlockingCollection** will be blocked (paused) if there is no room for additional items, or if they try to take items from an empty collection. The concurrent collections provide "try" versions of methods to extract items which return whether an action succeeded or not. This is because in the time between determining that there are items available and reading them it is possible that another task could have removed the items. The **ConcurrentDictionary** class provides additional methods for the conditional update of items in the dictionary.
- Multi-threaded applications are vulnerable to *race conditions* where actions by a task on a shared data item are not run to completion before that task is replaced by another.
- Race conditions can be addressed by making actions *atomic*, in that they will always complete before another task is allowed to perform the action. This is achieved by the use of lock objects. A task claims the lock and while it has the lock, other tasks trying to claim that lock and enter the atomic code will be blocked. This may results in a queue of blocked tasks waiting for a particular lock to be released.
- Two tasks waiting for locks from each other are said to be *deadlocked* or in a *deadly embrace*. Deadlocks can arise as a result of code which waits for access to a lock object while inside an atomic action. This should be addressed by good design.
- The Monitor mechanism for locking can be used in preference to the lock keyword if an application would benefit from tasks being able to determine whether or not hey can have access to an atomic action, rather than being blocked as soon as they try to aquire the lock.
- Simple actions, such as updating a particular variable, can be achieved by using the interlocked operations, rather than creating atomic blocks of code.
- Variables that may be used by multiple processes can be marked as "volatile". This tells the compiler not to perform optimisation such as caching the value of the variable in a processor register, or changing the order of the instructions.
- Tasks can be cancelled by the use of cancellation tokens. As a task runs it must check state of the token to determine if a cancellation has been requested. This is an important difference between a Task and a Thread. Threads can be aborted by another process at any time. One task can request that another task be cancelled, but this will only actually result in that thread ending if the code in the task is checking the cancellation token. Note that this does not mean that an active task can never be removed from memory however, because tasks run in the background they are automatically terminated upon completion of the foreground process that created them.
- Methods in an object my be made *thread safe* if they are to be used in applications that contain multiple tasks. Access to data members of the class containing the thread safe method must be managed in an atomic manner. Parameters passed into the method by reference are vulnerable to changes to elements in the parameter that may occur while the method is running.
- A **while** construction is useful in situations where you want to repeat something as long as condition is true. A do-while construction is useful in situations where you want to do something and then repeat if the action failed.
- A **for** construction is an easy way to perform initialisation, test and update actions on a **loop**. A for construction frequently involves the management of a counter value, but this is not the only way in which this construction can be used.
- A **foreach** construction can be used to enumerate the items in a collection. The collection provides a method that will provide an enumerator which is then iterated by the **foreach** construction. The items in the collection are provided as read-only.
- The **break** statement allows a program to exit a loop immediately. A large number of breaks in a loop can make it hard to discern the circumstances in which the loop exited. A loop can also be exited upon return from the method in which the loop is running and when code in the loop throws an exception that is not caught in the loop.
- The **continue** statement allows a program to return to the "top" of a loop and repeat the loop without going any further through the loop code. Note that any update and test behaviours will be performed when a continue statement runs.
- An **if** construction allows the conditional execution of a statement or block of statements. If constructions are controlled by a logical expression and can be followed by an else clause that identifies the statement to be performed if the condition is false. If conditions can be nested, an else portion of an if construction always binds to the "closest" if.
- Logical expressions evaluate to true or false. Variables can be compared using relational and equality operators. Logical values can be combined using **and**, **or** and **exclusive or** operators. The **and** operator and the **or** operator have "short circuit" versions that are only evaluated to the point where the value of the expression result can be determined.
- The **switch** construction allows the selective of a given behaviour from the value of a control value which can be an integer, string or character. A default behaviour can be specified if the control value does not match any of the selections.
- An expression contains operands and operators. The operands are literal values or variables. Operators have priority and associability that determine the point that the operator is applied during the evaluation of the expression.
- C# programs can use delegates to create variables that can serve as references to methods in objects. An object wishing to receive notifications from a publisher can use a delegate to specify a method to be called by the event publisher. A single publisher delegate makes calls to its subscribers, each of which has provided a delegate.
- The **event** keyword allows a delegate to be used in a secure way and the **EventArgs** classes describe a pattern that is used throughout .NET to allow events to deliver data into a subscriber.
- Delegates can also be used as references to individual methods. A delegate referring to a method can be regarded as a piece of data which describes an action.
- A lambda expression allows an action to be expressed directly and provides a convenient shorthand when writing code. The type of parameters and value returned by a lambda expression are inferred from the context of the call.
- An exception is thrown by a program to indicate a situation in which the program cannot continue normal operation. Execution is transferred from the statements being executed in a **try** block of code to an exception handler in a **catch** block, which was written to deal with the exception. An exception that is thrown in code that is not within a try construction will cause the executing thread to terminate.
- A **finally** element can be used in a try construction to specify code that will always be executed.
- A program throws an exception by creating a new exception instance and then using the **throw** keyword to throw it. All exception objects are derived from the Exception class. There are a large number of exception types that are used in the .NET libraries to describe error conditions; a programmer can also create their own exceptions types that contain their own error-specific information.
- An exception object contains information that describes the error, including a "stack trace" that indicates the point in the program source where the exception is thrown. An exception can also contain an inner exception reference so that a new exception can be wrapped around one that has been caught, before passing the exception to another layer of exception management.

#### Author: Rob Miles