# Manage program flow

- Multi-threading allows an application to be made up of a number of cooperating processes.
- When you create a multi-threaded application, its behaviours are spread amongst a number of co-operating tasks. The tasks may be performed in parallel if the host computer has multiple central processor units (CPUs). A single CPU will execute each active task in turn on a round-robin basis.
- Creating a multi-threaded application can be as simple as taking an existing set of actions and using the Task.Parallel library or PArallel LINQ to execute the actions as multiple tasks.
- The .NET Task class provides a high-level abstraction of a running task. Tasks can return values and continuation tasks can run automatically when one or more tasks complete. Tasks can also start child tasks, with the *parent* task being held until all the child tasks have completed.
- The .NET Thread class provides a lower level of abstraction of a running task. Threads cannot return results, nor can you create continuation threads. However, threads can run as foreground or background processes. Tasks can only run as background processes. A foreground process will run until complete, whereas a background process will be terminated upon the completion of the foreground process that created it. It is also possible to set the priority of a thread (although this is purely advisory, it doesn't guarantee that a given thread will be allowed a particular level of access to the processor).
- **Async** and **await** make it very easy to create multi-threaded applications. The **await** keyword precedes a call to a method that has been identified as asynchronous by the **async** keyword. An asynchronous method can return a Task (if the asynchronous method returns void) or a Task\<type> (if the method wishes to return a value). The compiler will generate code that allows an asynchronous method to return to the caller when the **await** keyword is reached. The statements following the **await** will be performed concurrently. This way of working is of particular value when building the user interface to a program. As asynchronous action bound to a button press will unblock the user interface at the first **await**, rather than stopping the user interface until the action performed by the button has completed. An application can catch exceptions thrown during asynchronous calls by enclosing the awaited action in an exception handler, but this only works if the awaited actions returns a value. For this reason, void asynchronous calls should be avoided as there is no way of determining whether they succeeded or not.
- The standard .NET collection classes are not *thread safe*. This means that if multiple tasks attempt to share data using a List, the contents of the list will be corrupted. The .NET framework provides a set of concurrent collections that can be shared by multiple active tasks. The **BlockingCollection** class provides a wrapper around **ConcurrentStack**, **ConcurrentQueue** and **ConcurrentBag** concurrent collections. Tasks using a **BlockingCollection** will be blocked (paused) if there is no room for additional items, or if they try to take items from an empty collection. The concurrent collections provide "try" versions of methods to extract items which return whether an action succeeded or not. This is because in the time between determining that there are items available and reading them it is possible that another task could have removed the items. The **ConcurrentDictionary** class provides additional methods for the conditional update of items in the dictionary.
- Multi-threaded applications are vulnerable to *race conditions* where actions by a task on a shared data item are not run to completion before that task is replaced by another.
- Race conditions can be addressed by making actions *atomic*, in that they will always complete before another task is allowed to perform the action. This is achieved by the use of lock objects. A task claims the lock and while it has the lock, other tasks trying to claim that lock and enter the atomic code will be blocked. This may results in a queue of blocked tasks waiting for a particular lock to be released.
- Two tasks waiting for locks from each other are said to be *deadlocked* or in a *deadly embrace*. Deadlocks can arise as a result of code which waits for access to a lock object while inside an atomic action. This should be addressed by good design.
- The Monitor mechanism for locking can be used in preference to the lock keyword if an application would benefit from tasks being able to determine whether or not hey can have access to an atomic action, rather than being blocked as soon as they try to aquire the lock.
- Simple actions, such as updating a particular variable, can be achieved by using the interlocked operations, rather than creating atomic blocks of code.
- Variables that may be used by multiple processes can be marked as "volatile". This tells the compiler not to perform optimisation such as caching the value of the variable in a processor register, or changing the order of the instructions.
- Tasks can be cancelled by the use of cancellation tokens. As a task runs it must check state of the token to determine if a cancellation has been requested. This is an important difference between a Task and a Thread. Threads can be aborted by another process at any time. One task can request that another task be cancelled, but this will only actually result in that thread ending if the code in the task is checking the cancellation token. Note that this does not mean that an active task can never be removed from memory however, because tasks run in the background they are automatically terminated upon completion of the foreground process that created them.
- Methods in an object my be made *thread safe* if they are to be used in applications that contain multiple tasks. Access to data members of the class containing the thread safe method must be managed in an atomic manner. Parameters passed into the method by reference are vulnerable to changes to elements in the parameter that may occur while the method is running.
- A **while** construction is useful in situations where you want to repeat something as long as condition is true. A do-while construction is useful in situations where you want to do something and then repeat if the action failed.
- A **for** construction is an easy way to perform initialisation, test and update actions on a **loop**. A for construction frequently involves the management of a counter value, but this is not the only way in which this construction can be used.
- A **foreach** construction can be used to enumerate the items in a collection. The collection provides a method that will provide an enumerator which is then iterated by the **foreach** construction. The items in the collection are provided as read-only.
- The **break** statement allows a program to exit a loop immediately. A large number of breaks in a loop can make it hard to discern the circumstances in which the loop exited. A loop can also be exited upon return from the method in which the loop is running and when code in the loop throws an exception that is not caught in the loop.
- The **continue** statement allows a program to return to the "top" of a loop and repeat the loop without going any further through the loop code. Note that any update and test behaviours will be performed when a continue statement runs.
- An **if** construction allows the conditional execution of a statement or block of statements. If constructions are controlled by a logical expression and can be followed by an else clause that identifies the statement to be performed if the condition is false. If conditions can be nested, an else portion of an if construction always binds to the "closest" if.
- Logical expressions evaluate to true or false. Variables can be compared using relational and equality operators. Logical values can be combined using **and**, **or** and **exclusive or** operators. The **and** operator and the **or** operator have "short circuit" versions that are only evaluated to the point where the value of the expression result can be determined.
- The **switch** construction allows the selective of a given behaviour from the value of a control value which can be an integer, string or character. A default behaviour can be specified if the control value does not match any of the selections.
- An expression contains operands and operators. The operands are literal values or variables. Operators have priority and associability that determine the point that the operator is applied during the evaluation of the expression.
- C# programs can use delegates to create variables that can serve as references to methods in objects. An object wishing to receive notifications from a publisher can use a delegate to specify a method to be called by the event publisher. A single publisher delegate makes calls to its subscribers, each of which has provided a delegate.
- The **event** keyword allows a delegate to be used in a secure way and the **EventArgs** classes describe a pattern that is used throughout .NET to allow events to deliver data into a subscriber.
- Delegates can also be used as references to individual methods. A delegate referring to a method can be regarded as a piece of data which describes an action.
- A lambda expression allows an action to be expressed directly and provides a convenient shorthand when writing code. The type of parameters and value returned by a lambda expression are inferred from the context of the call.
- An exception is thrown by a program to indicate a situation in which the program cannot continue normal operation. Execution is transferred from the statements being executed in a **try** block of code to an exception handler in a **catch** block, which was written to deal with the exception. An exception that is thrown in code that is not within a try construction will cause the executing thread to terminate.
- A **finally** element can be used in a try construction to specify code that will always be executed.
- A program throws an exception by creating a new exception instance and then using the **throw** keyword to throw it. All exception objects are derived from the Exception class. There are a large number of exception types that are used in the .NET libraries to describe error conditions; a programmer can also create their own exceptions types that contain their own error-specific information.
- An exception object contains information that describes the error, including a "stack trace" that indicates the point in the program source where the exception is thrown. An exception can also contain an inner exception reference so that a new exception can be wrapped around one that has been caught, before passing the exception to another layer of exception management.

# Create and use types

- Objects in a solution can be managed by value or by reference. A struct is a value type, which means that during assignment the contents of the struct (the value) is copied from one variable to another. A class is a reference type, which means that during assingment the destination of the assingment is made to refer to the same object as the source of the assingment.
- An immutable object is one that cannot be changed. Immutable objects, for example DateTime, provide methods that can be used to provide new, mutated copies of the original. For example, the DateTime structure provides a method that can be used to return a new DateTime structure that represents a given number of days into the future.
- A generic type can be used as a "placeholder" in a type design, so that the type of object that a type works on can be established dynamically. A good example of a situation where generic types are used is in the creation of lists and dictionaries.
- Types can be given a constructor method that is called when a new instance of the type is created. A constructor can be given parameters that can be used to initialise the object. If the constructor detects that the initialisation data is invalid it must interrupt the construction process by throwing an exception, as the object will be created when the constructor completes. Constructors can be overloaded to provide different ways in which a given type can be instantiated. By use of the "this" syntax one constructor in type can call another constructor, to allow the creation of a master constructor and avoid code duplication in objects. Classes can contain a static constructor, which is called once when the first instance of the class is created.
- Types can contain methods that allow an object to perform behaviours. A method accepts a number of parameters and has a particular type. A method of type void does not return a value, whereas a method with any other type must return a result of that type.
- An extension method can be added to a class to add to the functionality of the class. The extension method does not have access to any of the private data members of the class it is added to.
- Parameters to a method can be identified by their names when called. This improves the readability of programs and also reduces the likelihood of errors which may be caused by parameters being entered in the wrong sequence.
- Parameters to a method can be made optional by providing a default value for the parameter. If the parameter is left out of the method call the default value is used instead.
- Objects can provide indexed properties which can be used to provide an index value (usually an integer) to identify the item to be returned.
- Methods in a single type can be overloaded. This means that the type will contain multiple versions of the same method, each of which has a different signature. Method overloading is used in situations where there are multiple ways of performing a given task from different data inputs.
- Methods in a class hierarchy can be overridden. To be overridden a method must be marked as virtual. When a virtual method is called on an instance of a class in the hierarchy the system will search up the class hierarchy for an implementation of the method, starting at the class of the object. The first implementation that is found is called. Method overriding is used in situations where objects in a class hierarchy need to be able to perform a given action in their own particular way. The **base** keyword allows a method to call the method it has overridden.
- Every item in an application is of a particular type. The C# type system will automatically convert between reference and value types and automatically convert (widen) values when it is sensible to do so and no data will be lost.
- If a type conversion will result in data loss (narrowing) the programmer must use casting to explicitly request the conversion of the values.
- Dynamic types are provided so that a C# application can interact with languages and services which are not statically typed. They allow the compiler to be told to ignore the type of an object and build the program even if the typing information indicates errors.
- When a dynamic type is used the type of the variable that is created is inferred from the context of the use. This means that mistakes that would have been detected as compilation errors are now changed into run-time errors.
- Dynamic types are especially useful when interacting with Component Object Model (COM) based services as they can be automatically mapped onto the correct types from the context of their use.
- The C# access modifiers allow members of a class to be hidden from code outside the class. Unless you specify otherwise, class members are private to a class and not visible outside it. Making a data member public will allow uncontrolled access to that data member in the class, which may not be a good idea.
- C# properties allow get and set behaviours to get control when an external code wishes to interact with a member of a class. The property can control access to private member of the class that holds a *backing value* for the data that is being managed by the class. Properties can provide only get behaviours can have different access modifiers so that the get behaviour for a property can be made public and the set behaviour private.
- Generally speaking, methods that a class exposes for other classes to use should be made public, and data contained within the class should be made private.
- The **protected** access modifier allows a class member to be made visible within classes in a class hierarchy and the **internal** access modifier allows a class member to me made visible to code in the same assembly as the class member.
- Methods in a class that implement the behaviours of an interface can be identified as explicitly implementing this interface. This improves encapsulation as it means that the only context in which those methods can be used is via a reference to the interface, not a reference to the object. Explicit implementation of behaviours also removes the potential for confusion if a class implements multiple interfaces and the same method appears in some of the interfaces.
- A C# class can implement an interface that contains a set of method signatures. Implementing an interface involves providing a method that matches each of the methods described in the interface. A class that implements an interface can be referred to by references of the interface type.
- A C# class can serve as the base class for a child class that extends it. A child class inherits all of the members of the base class and can use the override mechanism to provide overridden version of methods in the base class which have a behaviour more specific to the child class. For a method in a base class to be overridden it must be declared as virtual. An overriding method can use the **base** keyword to call overridden methods in the base class.
- A programmer can create replacement methods for those in a base class. This is not to be encouraged.
- A class can be declared as sealed to prevent it from being used as the basis of child classes. Methods in a class that extend those in a base class can also be declared as sealed, preventing them from being overridden.
- To construct a child class a program needs to create an instance of the base class. If a base class has a constructor the child class must call this and supply any required parameters. The **base** keyword is used in the constructor for this purpose.
- A class can be declared as abstract, in which case it will contain signatures of methods which are to be implemented in child classes. Abstract classes can serve as templates for classes.
- A reference to a base class can refer to any objects that are created from classes that extend the base class. However, the reverse is not true. A reference to a child class is not able to be made to refer to an instance of the parent.
- A class can implement the **IComparable** interface. This means that it contains a method called **CompareTo** which can be used to determine the ordering of objects of that type. The **IComparable** behaviour can be used by methods such as the **Sort** method provided by the **List** type, which can place objects in order.
- A class can implement the **IEnumerable** interface, which means that it provides a method **GetEnumerator** which will supply an enumerator which can be used by a consumer of the enumeration (for example a **foreach** construction) to work through the class.
- The C# **yield** keyword provides an easy way for a programmer to create enumerators. It retains the state of the enumerator method until the next item is requested from the enumeration by the consumer of the enumeration.
- A class can implement the **IDisposable** interface. The class will contain a **Dispose** method that can be called to instruct an instance of the class to release critical resources that it is using. The **Dispose** method is not called automatically by the garbage collection process, but it can be called automatically if the instance of the object is created and used within a C# program using construction.
- The **IUnknown** interface can be used when creating .NET code that must interact directly with Component Object Model (COM) objects.
- Metadata is data about data. In the context of a C# program, the metadata for the code would be expressed in the form of one or more attribute instances that are attached to code elements. This metadata is stored in the assembly file that is created when the program is built and loaded into attribute class instances when the assembly is loaded.
- Attribute classes extend the Attribute class and have names that end with the text "Attribute". An attribute class can be empty, in which case it just indicates that a particular attribute is applied to an item, or an attribute can contain data elements which can be accessed programmatically. Attributes can be applied to many different elements in a program; an **AttributeUseage** attribute can be added to an attribute declaration to specify objects and classes that can have an attribute applied.
- Reflection allows a program to investigate the contents of a type and programmatically interact with it.
- Reflection can be used on an assembly to allow a program to determine the characteristics of types in the assembly. This can be used to allow a component-based system to automatically select and load the components that it needs.
- Program's code can be created programmatically by using the CodeDOM document model which allows namespaces, classes, properties and class members to be specified. A CodeDOM object can be output as a binary assembly file or as a source file in C# or Visual Basic.
- Another way to programmatically create code behaviours is to create lambda expression trees which contain lambda expressions that give the actions to be performed, along with a range of expression node types that specify other program actions. Expression trees are used to express programmatic behaviour for such things as LINQ queries and the implementation of dynamic languages.
- Garbage collection of objects makes program creation much easier. The garbage collection system in C# runs automatically and will delete unused objects (those that are not referred to by any reference).
- Application threads are paused while the garbage collection process runs.
- The garbage collector recognises persistent objects (those which are present after a garbage collection) and omits those from the garbage collection process.
- The garbage collection process can be initiated manually, although this is not recommended.
- Unused objects that contain references to resources that need to be released when the object is deleted can contain a finaliser method that is executed during the garbage collection process. The finaliser method can release resources allocated to the object.
- In preference to a finaliser method, an object can implement the **IDisposable** interface and contain a **Dispose** method that can be used by the application to instruct the object to release any resources. The using statement can be used to ensure that the **Dispose** method is called on an object which is used in only one part of a program.
- By using the dispose pattern, an object can combine the use of finaliser and **Dispose** to ensure that resources held by the object are released correctly.
- A string is a collection of characters of arbitrary length.
- String variables are immutable (they cannot be changed) but they are managed by reference. This combination means that they can be treated as value types.
- During compilation multiple copies of string literals for a particular string are mapped onto a single string instance in memory. In other words, if a program assigns the string literal "cheese" to several different string variables this would result in a single string value containing the text "cheese" being created to which all the variables would be made to refer.
- Building up a large string by adding many strings together will result in the creation of a large number of substrings. The **StringBuilder** type provides a string implementation which is mutable. A program can modify the contents in a **StringBuilder** instance. **StringBuilders** provide a more efficient means of assembling large strings.
- The **StringReader** and **StringWriter** classes allow strings to be used by programs that work with **TextReader** and **TextWriter** streams.
- The string type provides a range of methods for working with strings. It is possible to establish the location of substrings within the string, extract them and match the start and the end of a string.
- The contents of a string cannot be changed (strings are immutable) but the **Replace** string method can be used to create a new string instance with updated contents.
- String matching can be performed using the character codes or according to particular cultures where multiple spellings of the same word may be matched.
- Strings can be enumerated, for example by using **foreach** construction.
- Strings can implement the **IFormattable** interface, which means that they will contain an additional **ToString** method that accepts formatting and culture information.
- String interpolation allows a program to use string literals (preceded by a $ character) that combine formatting information and the names of variables to be formatted and incorporated into the string. Interpolated strings are processed at compile time to produce composite format strings.
 
#### Author: Rob Miles